'use strict';

var query = function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(qtype, name) {
    var buf;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            buf = packet.encode({
              type: 'query',
              id: 1,
              flags: packet.RECURSION_DESIRED,
              questions: [{
                type: qtype,
                class: 'IN',
                name: name
              }],
              additionals: [{
                type: 'OPT',
                name: '.',
                udpPayloadSize: 4096,
                flags: packet.DNSSEC_OK
              }]
            });
            _context.next = 3;
            return getDNS(buf);

          case 3:
            return _context.abrupt('return', _context.sent);

          case 4:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function query(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

var queryWithProof = function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(qtype, name) {
    var r, sigs, rrs, ret, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, sig;

    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return query(qtype, name);

          case 2:
            r = _context2.sent;
            _context2.next = 5;
            return filterRRs(r.answers, ['RRSIG']);

          case 5:
            sigs = _context2.sent;
            rrs = getRRset(r.answers, name, qtype);
            ret = void 0;


            if (r.authorities.length > 0) {
              sigs = filterRRSIGWithTypeCovered(r.authorities, ['NSEC', 'NSEC3']);
              rrs = filterRRs(r.authorities, ['NSEC', 'NSEC3']);
            }

            if (!(rrs.length == 0)) {
              _context2.next = 11;
              break;
            }

            return _context2.abrupt('return', {
              found: false,
              nsec: false,
              results: []
            });

          case 11:
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _iteratorError = undefined;
            _context2.prev = 14;
            _iterator = sigs[Symbol.iterator]();

          case 16:
            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
              _context2.next = 27;
              break;
            }

            sig = _step.value;
            _context2.next = 20;
            return verifyRRSet(sig, rrs);

          case 20:
            ret = _context2.sent;

            if (!ret) {
              _context2.next = 24;
              break;
            }

            ret.push(new SignedSet(name, sig, rrs));
            return _context2.abrupt('return', ret);

          case 24:
            _iteratorNormalCompletion = true;
            _context2.next = 16;
            break;

          case 27:
            _context2.next = 33;
            break;

          case 29:
            _context2.prev = 29;
            _context2.t0 = _context2['catch'](14);
            _didIteratorError = true;
            _iteratorError = _context2.t0;

          case 33:
            _context2.prev = 33;
            _context2.prev = 34;

            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }

          case 36:
            _context2.prev = 36;

            if (!_didIteratorError) {
              _context2.next = 39;
              break;
            }

            throw _iteratorError;

          case 39:
            return _context2.finish(36);

          case 40:
            return _context2.finish(33);

          case 41:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, this, [[14, 29, 33, 41], [34,, 36, 40]]);
  }));

  return function queryWithProof(_x3, _x4) {
    return _ref2.apply(this, arguments);
  };
}();

var verifyRRSet = function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(sig, rrs) {
    var sigHeaderName, rrsHeaderRtype, sigdata, rrsdata, keys, sets, signersName, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, key, header, keyTag;

    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            sigHeaderName = sig.name;
            rrsHeaderRtype = rrs[0].type;
            sigdata = sig.data;
            rrsdata = rrs[0].data[0];
            keys = [];
            sets = void 0;
            signersName = sigdata.signersName;

            if (!(sigHeaderName == sigdata.signersName && rrsHeaderRtype == 'DNSKEY')) {
              _context3.next = 11;
              break;
            }

            keys = rrs;
            _context3.next = 17;
            break;

          case 11:
            _context3.next = 13;
            return queryWithProof('DNSKEY', sigdata.signersName);

          case 13:
            sets = _context3.sent;

            if (sets) {
              _context3.next = 16;
              break;
            }

            throw 'No sets found on ' + sigdata.signersName;

          case 16:
            keys = sets[sets.length - 1].rrs;

          case 17:
            _iteratorNormalCompletion2 = true;
            _didIteratorError2 = false;
            _iteratorError2 = undefined;
            _context3.prev = 20;
            _iterator2 = keys[Symbol.iterator]();

          case 22:
            if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
              _context3.next = 35;
              break;
            }

            key = _step2.value;
            header = getHeader(key);
            keyTag = getKeyTag(header);

            if (!(key.data.algorithm != sig.data.algorithm || keyTag != sig.data.keyTag || key.name != sig.data.signersName)) {
              _context3.next = 28;
              break;
            }

            return _context3.abrupt('continue', 32);

          case 28:
            if (!(sig.name == sig.data.signersName && rrsHeaderRtype == 'DNSKEY')) {
              _context3.next = 32;
              break;
            }

            _context3.next = 31;
            return verifyWithDS(key);

          case 31:
            sets = _context3.sent;

          case 32:
            _iteratorNormalCompletion2 = true;
            _context3.next = 22;
            break;

          case 35:
            _context3.next = 41;
            break;

          case 37:
            _context3.prev = 37;
            _context3.t0 = _context3['catch'](20);
            _didIteratorError2 = true;
            _iteratorError2 = _context3.t0;

          case 41:
            _context3.prev = 41;
            _context3.prev = 42;

            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }

          case 44:
            _context3.prev = 44;

            if (!_didIteratorError2) {
              _context3.next = 47;
              break;
            }

            throw _iteratorError2;

          case 47:
            return _context3.finish(44);

          case 48:
            return _context3.finish(41);

          case 49:
            if (!(typeof sets != 'undefined')) {
              _context3.next = 53;
              break;
            }

            return _context3.abrupt('return', sets);

          case 53:
            throw 'No matching keytag ' + sig.data.keyTag + ' for signer ' + sig.data.signersName + ' with algo ' + sig.data.algorithm + ' and rrs header type ' + rrsHeaderRtype;

          case 54:
          case 'end':
            return _context3.stop();
        }
      }
    }, _callee3, this, [[20, 37, 41, 49], [42,, 44, 48]]);
  }));

  return function verifyRRSet(_x5, _x6) {
    return _ref3.apply(this, arguments);
  };
}();

var verifyWithDS = function () {
  var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(key) {
    var header, keyTag, matched, sets;
    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            header = getHeader(key);
            keyTag = getKeyTag(header);
            matched = TRUST_ANCHORS.filter(function (anchor) {
              return anchor.name == key.name && anchor.data.algorithm == key.data.algorithm && anchor.data.keyTag == keyTag && checkDigest(anchor, key.name, header, key.data.digestType || key.data.algorithm);
            });

            if (!(matched && matched.length > 0)) {
              _context4.next = 5;
              break;
            }

            return _context4.abrupt('return', []);

          case 5:
            _context4.next = 7;
            return queryWithProof('DS', key.name);

          case 7:
            sets = _context4.sent;

            sets[sets.length - 1].rrs.forEach(function (ds) {
              if (checkDigest(ds, key.name, header, key.data.digestType || key.data.algorithm)) {
                return sets;
              }
            });
            return _context4.abrupt('return', sets);

          case 10:
          case 'end':
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));

  return function verifyWithDS(_x7) {
    return _ref4.apply(this, arguments);
  };
}();

var getDNS = function () {
  var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(buf) {
    var response, buffer, decoded;
    return regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return fetch(DNS_URL + buf.toString('base64') + '&ts=' + Date.now());

          case 2:
            response = _context5.sent;
            buffer = void 0;

            if (!(typeof response.arrayBuffer === 'function')) {
              _context5.next = 10;
              break;
            }

            _context5.next = 7;
            return response.arrayBuffer();

          case 7:
            buffer = _context5.sent;
            _context5.next = 17;
            break;

          case 10:
            if (!(typeof response.buffer === 'function')) {
              _context5.next = 16;
              break;
            }

            _context5.next = 13;
            return response.buffer();

          case 13:
            buffer = _context5.sent;
            _context5.next = 17;
            break;

          case 16:
            throw 'this environment does not have function to support buffer';

          case 17:
            decoded = packet.decode(Buffer.from(buffer));
            return _context5.abrupt('return', decoded);

          case 19:
          case 'end':
            return _context5.stop();
        }
      }
    }, _callee5, this);
  }));

  return function getDNS(_x8) {
    return _ref5.apply(this, arguments);
  };
}();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

require('es6-promise').polyfill();
require('isomorphic-fetch');
var packet = require('dns-packet');
var SignedSet = require('./signed_set.js');
var Util = require('../util.js');
var getHeader = Util.getHeader;
var getKeyTag = Util.getKeyTag;
var checkDigest = Util.checkDigest;
var DNS_URL = 'https://cloudflare-dns.com/dns-query?ct=application/dns-udpwireformat&dns=';

var TRUST_ANCHORS = [{
  name: '.',
  type: 'DS',
  class: 'IN',
  data: {
    keyTag: 19036,
    algorithm: 8,
    digestType: 2,
    digest: new Buffer('49AAC11D7B6F6446702E54A1607371607A1A41855200FD2CE1CDDE32F24E8FB5', 'hex')
  }
}, {
  name: '.',
  type: 'DS',
  class: 'IN',
  data: {
    keyTag: 20326,
    algorithm: 8,
    digestType: 2,
    digest: new Buffer('E06D44B80B8F1D39A95C0B0D7C65D08458E880409BBC683457104237C7F8EC8D', 'hex')
  }
},
// This is dummy entry for testing
{
  name: '.',
  type: 'DS',
  class: 'IN',
  data: {
    keyTag: 5647,
    algorithm: 253,
    digestType: 253,
    digest: new Buffer([])
  }
}];

function filterRRs(rrs, qtypes) {
  return rrs.filter(function (r) {
    return qtypes.includes(r.type);
  });
}

function filterRRSIGWithTypeCovered(rrs, qtypes) {
  return rrs.filter(function (r) {
    return r.type == 'RRSIG' && qtypes.includes(r.data.typeCovered);
  });
}

function getRRset(rrs, name, qtype) {
  return rrs.filter(function (r) {
    return r.type == qtype && r.name == name;
  });
}

module.exports.queryWithProof = queryWithProof;