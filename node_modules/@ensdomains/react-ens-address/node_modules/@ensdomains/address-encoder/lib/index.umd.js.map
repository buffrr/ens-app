{"version":3,"file":"index.umd.js","sources":["../src/index.ts"],"sourcesContent":["import { decode as bech32Decode, encode as bech32Encode, fromWords as bech32FromWords, toWords as bech32ToWords } from 'bech32';\n// @ts-ignore\nimport { b32decode, b32encode, bs58Decode, bs58Encode, cashaddrDecode, cashaddrEncode, codec as xrpCodec, decodeCheck as decodeEd25519PublicKey, encodeCheck as encodeEd25519PublicKey, eosPublicKey, hex2a, isValid as isValidXemAddress, isValidChecksumAddress as rskIsValidChecksumAddress, ss58Decode, ss58Encode, stripHexPrefix as rskStripHexPrefix, toChecksumAddress as rskToChecksumAddress, ua2hex } from 'crypto-addr-codec';\n\ntype EnCoder = (data: Buffer) => string\ntype DeCoder = (data: string) => Buffer\n\ninterface IFormat {\n  coinType: number;\n  name: string;\n  encoder: (data: Buffer) => string;\n  decoder: (data: string) => Buffer;\n}\n\nfunction makeBitcoinBase58CheckEncoder(p2pkhVersion: number, p2shVersion: number): (data: Buffer) => string {\n  return (data: Buffer) => {\n    let addr: Buffer;\n    switch (data.readUInt8(0)) {\n      case 0x76: // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n        if (\n          data.readUInt8(1) !== 0xa9 ||\n          data.readUInt8(data.length - 2) !== 0x88 ||\n          data.readUInt8(data.length - 1) !== 0xac\n        ) {\n          throw Error('Unrecognised address format');\n        }\n        addr = Buffer.concat([Buffer.from([p2pkhVersion]), data.slice(3, 3 + data.readUInt8(2))]);\n        // @ts-ignore\n        return bs58Encode(addr);\n      case 0xa9: // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n        if (data.readUInt8(data.length - 1) !== 0x87) {\n          throw Error('Unrecognised address format');\n        }\n        addr = Buffer.concat([Buffer.from([p2shVersion]), data.slice(2, 2 + data.readUInt8(1))]);\n        return bs58Encode(addr);\n      default:\n        throw Error('Unrecognised address format');\n    }\n  };\n}\n\nfunction makeBitcoinBase58CheckDecoder(p2pkhVersions: number[], p2shVersions: number[]): (data: string) => Buffer {\n  return (data: string) => {\n    const addr = bs58Decode(data);\n    const version = addr.readUInt8(0);\n    if (p2pkhVersions.includes(version)) {\n      return Buffer.concat([Buffer.from([0x76, 0xa9, 0x14]), addr.slice(1), Buffer.from([0x88, 0xac])]);\n    } else if (p2shVersions.includes(version)) {\n      return Buffer.concat([Buffer.from([0xa9, 0x14]), addr.slice(1), Buffer.from([0x87])]);\n    }\n    throw Error('Unrecognised address format');\n  };\n}\n\nconst bitcoinBase58Chain = (name: string, coinType: number, p2pkhVersions: number[], p2shVersions: number[]) => ({\n  coinType,\n  decoder: makeBitcoinBase58CheckDecoder(p2pkhVersions, p2shVersions),\n  encoder: makeBitcoinBase58CheckEncoder(p2pkhVersions[0], p2shVersions[0]),\n  name,\n});\n\nfunction makeBech32SegwitEncoder(hrp: string): (data: Buffer) => string {\n  return (data: Buffer) => {\n    let version = data.readUInt8(0);\n    if (version >= 0x51 && version <= 0x60) {\n      version -= 0x50;\n    } else if (version !== 0x00) {\n      throw Error('Unrecognised address format');\n    }\n\n    const words = [version].concat(bech32ToWords(data.slice(2, data.readUInt8(1) + 2)));\n    return bech32Encode(hrp, words);\n  };\n}\n\nfunction makeBech32SegwitDecoder(hrp: string): (data: string) => Buffer {\n  return (data: string) => {\n    const { prefix, words } = bech32Decode(data);\n    if (prefix !== hrp) {\n      throw Error('Unexpected human-readable part in bech32 encoded address');\n    }\n    const script = bech32FromWords(words.slice(1));\n    let version = words[0];\n    if (version > 0) {\n      version += 0x50;\n    }\n    return Buffer.concat([Buffer.from([version, script.length]), Buffer.from(script)]);\n  };\n}\n\nfunction makeBitcoinEncoder(hrp: string, p2pkhVersion: number, p2shVersion: number): (data: Buffer) => string {\n  const encodeBech32 = makeBech32SegwitEncoder(hrp);\n  const encodeBase58Check = makeBitcoinBase58CheckEncoder(p2pkhVersion, p2shVersion);\n  return (data: Buffer) => {\n    try {\n      return encodeBase58Check(data);\n    } catch {\n      return encodeBech32(data);\n    }\n  };\n}\n\nfunction makeBitcoinDecoder(hrp: string, p2pkhVersions: number[], p2shVersions: number[]): (data: string) => Buffer {\n  const decodeBech32 = makeBech32SegwitDecoder(hrp);\n  const decodeBase58Check = makeBitcoinBase58CheckDecoder(p2pkhVersions, p2shVersions);\n  return (data: string) => {\n    if (data.toLowerCase().startsWith(hrp + '1')) {\n      return decodeBech32(data);\n    } else {\n      return decodeBase58Check(data);\n    }\n  };\n}\n\nconst bitcoinChain = (\n  name: string,\n  coinType: number,\n  hrp: string,\n  p2pkhVersions: number[],\n  p2shVersions: number[],\n) => ({\n  coinType,\n  decoder: makeBitcoinDecoder(hrp, p2pkhVersions, p2shVersions),\n  encoder: makeBitcoinEncoder(hrp, p2pkhVersions[0], p2shVersions[0]),\n  name,\n});\n\nfunction encodeCashAddr(data: Buffer): string {\n  switch (data.readUInt8(0)) {\n    case 0x76: // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n      if (\n        data.readUInt8(1) !== 0xa9 ||\n        data.readUInt8(data.length - 2) !== 0x88 ||\n        data.readUInt8(data.length - 1) !== 0xac\n      ) {\n        throw Error('Unrecognised address format');\n      }\n      return cashaddrEncode('bitcoincash', 0, data.slice(3, 3 + data.readUInt8(2)));\n    case 0xa9: // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n      if (data.readUInt8(data.length - 1) !== 0x87) {\n        throw Error('Unrecognised address format');\n      }\n      return cashaddrEncode('bitcoincash', 1, data.slice(2, 2 + data.readUInt8(1)));\n    default:\n      throw Error('Unrecognised address format');\n  }\n}\n\nfunction decodeCashAddr(data: string): Buffer {\n  const { prefix, type, hash } = cashaddrDecode(data);\n  if (type === 0) {\n    return Buffer.concat([Buffer.from([0x76, 0xa9, 0x14]), Buffer.from(hash), Buffer.from([0x88, 0xac])]);\n  } else if (type === 1) {\n    return Buffer.concat([Buffer.from([0xa9, 0x14]), Buffer.from(hash), Buffer.from([0x87])]);\n  }\n  throw Error('Unrecognised address format');\n}\n\nfunction decodeBitcoinCash(data: string): Buffer {\n  const decodeBase58Check = makeBitcoinBase58CheckDecoder([0x00], [0x05]);\n  try {\n    return decodeBase58Check(data);\n  } catch {\n    return decodeCashAddr(data);\n  }\n}\n\nfunction makeChecksummedHexEncoder(chainId?: number) {\n  return (data: Buffer) => rskToChecksumAddress(data.toString('hex'), chainId || null);\n}\n\nfunction makeChecksummedHexDecoder(chainId?: number) {\n  return (data: string) => {\n    const stripped = rskStripHexPrefix(data);\n    if (\n      !rskIsValidChecksumAddress(data, chainId || null) &&\n      stripped !== stripped.toLowerCase() &&\n      stripped !== stripped.toUpperCase()\n    ) {\n      throw Error('Invalid address checksum');\n    }\n    return Buffer.from(rskStripHexPrefix(data), 'hex');\n  };\n}\n\nconst hexChecksumChain = (name: string, coinType: number, chainId?: number) => ({\n  coinType,\n  decoder: makeChecksummedHexDecoder(chainId),\n  encoder: makeChecksummedHexEncoder(chainId),\n  name,\n});\n\nfunction makeBech32Encoder(prefix: string) {\n  return (data: Buffer) => bech32Encode(prefix, bech32ToWords(data));\n}\n\nfunction makeBech32Decoder(currentPrefix: string) {\n  return (data: string) => {\n    const { prefix, words } = bech32Decode(data);\n    if (prefix !== currentPrefix) {\n      throw Error('Unrecognised address format');\n    }\n    return Buffer.from(bech32FromWords(words));\n  }\n}\n\nconst bech32Chain = (name: string, coinType: number, prefix: string) => ({\n  coinType,\n  decoder: makeBech32Decoder(prefix),\n  encoder: makeBech32Encoder(prefix),\n  name,\n});\n\nfunction b32encodeXemAddr(data: Buffer): string {\n  return b32encode(hex2a(data.toString('hex')));\n}\n\nfunction b32decodeXemAddr(data: string): Buffer {\n  if (!isValidXemAddress(data)) {\n    throw Error('Unrecognised address format');\n  }\n  const address = data.toString().toUpperCase().replace(/-/g, '');\n  return b32decode(address)\n}\n\nfunction eosAddrEncoder(data: Buffer): string {\n  if (!eosPublicKey.isValid(data)) {\n    throw Error('Unrecognised address format');\n  }\n  return eosPublicKey.fromHex(data).toString();\n}\n\nfunction eosAddrDecoder(data: string): Buffer {\n  if (!eosPublicKey.isValid(data)) {\n    throw Error('Unrecognised address format');\n  }\n  return eosPublicKey(data).toBuffer();\n}\n\nfunction ksmAddrEncoder(data: Buffer): string {\n  return ss58Encode(Uint8Array.from(data), 2)\n}\n\nfunction dotAddrEncoder(data: Buffer): string {\n  return ss58Encode(Uint8Array.from(data), 0)\n}\n\nfunction ksmAddrDecoder(data: string): Buffer {\n  return new Buffer(ss58Decode(data))\n}\n\nfunction strDecoder(data: string): Buffer {\n  return decodeEd25519PublicKey('ed25519PublicKey', data)\n}\n\nfunction strEncoder(data: Buffer): string {\n  return encodeEd25519PublicKey('ed25519PublicKey', data)\n}\n\n// Referenced from the followings\n// https://tezos.stackexchange.com/questions/183/base58-encoding-decoding-of-addresses-in-micheline\n// https://tezos.gitlab.io/api/p2p.html?highlight=contract_id#contract-id-22-bytes-8-bit-tag\nfunction tezosAddressEncoder(data: Buffer): string {\n  if (data.length !== 22 && data.length !== 21) { throw Error('Unrecognised address format'); }\n\n  let prefix: Buffer;\n  switch (data.readUInt8(0)) {\n    case 0x00:\n      if (data.readUInt8(1) === 0x00) {\n          prefix = Buffer.from([0x06, 0xa1, 0x9f]); // prefix tz1 equal 06a19f\n      } else if (data.readUInt8(1) === 0x01) {\n          prefix = Buffer.from([0x06, 0xa1, 0xa1]); // prefix tz2 equal 06a1a1\n      } else if (data.readUInt8(1) === 0x02) {\n          prefix = Buffer.from([0x06, 0xa1, 0xa4]); // prefix tz3 equal 06a1a4\n      } else {\n          throw Error('Unrecognised address format');\n      }\n      return bs58Encode(Buffer.concat([prefix, data.slice(2)]));\n    case 0x01:\n      prefix = Buffer.from([0x02, 0x5a, 0x79]); // prefix KT1 equal 025a79\n      return bs58Encode(Buffer.concat([prefix, data.slice(1, 21)]));\n    default:\n      throw Error('Unrecognised address format');\n  }\n}\n\nfunction tezosAddressDecoder(data: string): Buffer {\n  const address = bs58Decode(data).slice(3);\n  switch (data.substring(0,3)) {\n    case \"tz1\": \n      return Buffer.concat([Buffer.from([0x00,0x00]), address]);\n    case \"tz2\":\n      return Buffer.concat([Buffer.from([0x00,0x01]), address]);\n    case \"tz3\":\n      return Buffer.concat([Buffer.from([0x00,0x02]), address]);\n    case \"KT1\":\n      return Buffer.concat([Buffer.from([0x01]), address, Buffer.from([0x00])]);\n    default:\n      throw Error('Unrecognised address format');\n  }\n}\n\nconst getConfig = (name: string, coinType: number, encoder: EnCoder, decoder: DeCoder) => {\n  return {\n    coinType,\n    decoder,\n    encoder,\n    name,\n  }\n}\n\nconst formats: IFormat[] = [\n  bitcoinChain('BTC', 0, 'bc', [0x00], [0x05]),\n  bitcoinChain('LTC', 2, 'ltc', [0x30], [0x32, 0x05]),\n  bitcoinBase58Chain('DOGE', 3, [0x1e], [0x16]),\n  bitcoinBase58Chain('DASH', 5, [0x4c], [0x10]),\n  bitcoinBase58Chain('PPC', 6, [0x37], [0x75]),\n  bitcoinChain('MONA', 22, 'mona', [0x32], [0x37, 0x05]),\n  getConfig('XEM', 43, b32encodeXemAddr, b32decodeXemAddr),\n  hexChecksumChain('ETH', 60),\n  hexChecksumChain('ETC', 61),\n  bech32Chain('ATOM', 118, 'cosmos'),\n  bech32Chain('ZIL', 119, 'zil'),\n  hexChecksumChain('RSK', 137, 30),\n  getConfig('XRP', 144, (data) => xrpCodec.encodeChecked(data), (data) => xrpCodec.decodeChecked(data)),\n  getConfig('BCH', 145, encodeCashAddr, decodeBitcoinCash),\n  getConfig('XLM', 148, strEncoder, strDecoder),\n  getConfig('EOS', 194, eosAddrEncoder, eosAddrDecoder),\n  getConfig('TRX', 195, bs58Encode, bs58Decode),\n  getConfig('NEO', 239, bs58Encode, bs58Decode),\n  getConfig('DOT', 354, dotAddrEncoder, ksmAddrDecoder),\n  getConfig('SOL', 501, bs58Encode, bs58Decode),\n  getConfig('KSM', 434, ksmAddrEncoder, ksmAddrDecoder),\n  hexChecksumChain('XDAI', 700),\n  hexChecksumChain('VET', 703),\n  bech32Chain('BNB', 714, 'bnb'),\n  {\n    coinType: 1729,\n    decoder: tezosAddressDecoder,\n    encoder: tezosAddressEncoder,\n    name: 'XTZ',\n  },\n  bech32Chain('ADA', 1815, 'addr'),\n  hexChecksumChain('CELO', 52752)\n];\n\nexport const formatsByName: { [key: string]: IFormat } = Object.assign({}, ...formats.map(x => ({ [x.name]: x })));\nexport const formatsByCoinType: { [key: number]: IFormat } = Object.assign(\n  {},\n  ...formats.map(x => ({ [x.coinType]: x })),\n);\n"],"names":["makeBitcoinBase58CheckEncoder","p2pkhVersion","p2shVersion","data","addr","readUInt8","length","Error","Buffer","concat","from","slice","bs58Encode","makeBitcoinBase58CheckDecoder","p2pkhVersions","p2shVersions","bs58Decode","version","includes","bitcoinBase58Chain","name","coinType","decoder","encoder","makeBitcoinEncoder","hrp","encodeBech32","words","bech32ToWords","bech32Encode","makeBech32SegwitEncoder","encodeBase58Check","makeBitcoinDecoder","decodeBech32","bech32Decode","prefix","script","bech32FromWords","makeBech32SegwitDecoder","decodeBase58Check","toLowerCase","startsWith","bitcoinChain","makeChecksummedHexEncoder","chainId","rskToChecksumAddress","toString","makeChecksummedHexDecoder","stripped","rskStripHexPrefix","rskIsValidChecksumAddress","toUpperCase","hexChecksumChain","makeBech32Encoder","bech32Chain","currentPrefix","ksmAddrDecoder","ss58Decode","getConfig","formats","b32encode","hex2a","isValidXemAddress","address","replace","b32decode","xrpCodec","encodeChecked","decodeChecked","cashaddrEncode","cashaddrDecode","type","hash","decodeCashAddr","encodeEd25519PublicKey","decodeEd25519PublicKey","eosPublicKey","isValid","fromHex","toBuffer","ss58Encode","Uint8Array","substring","formatsByName","Object","assign","map","x","formatsByCoinType"],"mappings":"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"}